"""Dhruv K Patel, Summer 2016Purpose: to recieve, process, and analyze Lidar data - HStarTech AMP I mobile base simulation class - Hokuyo UTM-30LX/UST-10LX Lidar data acquisition ClassLook at DataViewer.py for example on how to use this module"""import sys, serial, timefrom math import sin, cos, atan, degrees, radians, sqrt, fabs, pi, expfrom hokuyo.driver import hokuyo        # For UTM-30LXfrom hokuyo.tools import serial_port    #     ..import pyudev                           #     ..from hokuyolx import HokuyoLX           # For UST10LXimport matplotlib.patches as mpatchesfrom matplotlib.patches import FancyBboxPatch as box"""------------------Control Parameters------------------"""COLLISION_SEARCH_RADIUS = 1000              # (mm) - Collision search ignores all points outside of radiusCOLLISION_SEARCH_TIME_BOUNDARY = 1          # (sec) - time boundary at which control factor kicks onCOLLISION_SEARCH_RESOLUTION = 10            # (n/a) - splitting factor for theta curvingCOLLISION_SEARCH_ERROR = 2                  # (mm) distance from object in which collision is assumedCONTROL_FACTOR_INCREMENT = 1                # (s^-1) limitation to amount control factor can change per second"""-----------------------------------------------------------------Base Class:   For plotting and modeling data that pertain to the mobile base-----------------------------------------------------------------"""class Base:    # Plotting, Simulation & Analysis    def __init__(self, base_h, base_w, base_x, base_y):        """        Creates an object for robot mobile base.        x and y coordinates from base center        Reference base from bird's eye view with electric box on bottom side        """        self.vx = 0     # (mm/s) speed in x direction        self.vy = 0     # (mm/s) speed in y direction        self.vth = 0    # (deg/s) speed of rotation        self.cf_prev = 1.0 # previous control factor        self.previous_time = time.time()        self.h = base_h        self.w = base_w        self.x = base_x        self.y = base_y        self.dt = 0     # initialized for filtering        self.scanTime = 0        # Find base points        self.points = [0] * 4        # Fill top (right to left)        self.points[0] = [[0] * self.w, [int(round(self.h / 2) + self.y)] * self.w]        for point in range(0, self.w):            self.points[0][0][point] = int(round((self.x + (self.w / 2) - point)))        # Fill left (top to bottom)        self.points[1] = [[int(round(-(self.w / 2) + self.x))] * self.h, [0] * self.h]        for point in range(0, self.h):            self.points[1][1][point] = int(round((self.y + (self.h / 2) - point)))        # Fill bottom (left to right)        self.points[2] = [[0] * self.w, [int(round(-self.h / 2) + self.y)] * self.w]        for point in range(0, self.w):            self.points[2][0][point] = int(round(self.x - (self.w / 2) + point))        # Fill right (bottom top)        self.points[3] = [[int(round((self.w / 2) + self.x))] * self.h, [0] * self.h]        for point in range(0, self.h):            self.points[3][1][point] = int(round((self.y - (self.h / 2) + point)))    def plot_base(self, axis):        """        Plots base using matplotlib        :param axis: matplotlib figure to plot on        :return:        """        pad_val = 40  # This is to round the edges of the robot base        robot_base = box((self.x - (self.w / 2) + pad_val, self.y - (self.h / 2) + pad_val), self.w - (2 * pad_val),                         self.h - (2 * pad_val), boxstyle=mpatches.BoxStyle("Round", pad=pad_val), ec="b", fc="#00E9FC")        axis.clear()        axis.add_patch(robot_base)        axis.plot(self.x + self.w/2 - 49, self.y, 'k>', markersize = 8)    def dist_to_base(self, x, y):        """        Computes shortest distance from point to base        :param x: X coordinate of point (mm)        :param y: Y coordinate of point (mm)        :return: [Shortest distance from point to base (mm), Corner code]        * Collision code:        0: top right corner (relative to cartesian plane)        1: top side        2: top left corner        3: left side        4: bottom left corner        5: bottom side        6: bottom right corner        7: right side        """        if (self.x - (self.w / 2)) < x < (self.x + (self.w / 2)) and (self.y - (self.h / 2)) < y < (self.y + (self.h / 2)):            return [0, 0]        corner_dists = [0]*4        for side in range(len(self.points)):            corner_dists[side] = _distance(self.points[side][0][0], self.points[side][1][0], x, y)        corner = corner_dists.index(min(corner_dists))        if type(corner) == list:            corner_x = self.points[corner[0]][0][0]            corner_y = self.points[corner[0]][1][0]        else:            corner_x = self.points[corner][0][0]            corner_y = self.points[corner][1][0]                # top right        if corner == 0:               if x > corner_x and y > corner_y:                return [_distance(x, y, corner_x, corner_y), 0]            elif x > corner_x:                return [_distance(0, x, 0, corner_x), 7]            elif y > corner_y:                return [_distance(y, 0, corner_y, 0), 1]            else:                 return [0, 0]        # top left        elif corner == 1:            if x < corner_x and y > corner_y:                return [_distance(x, y, corner_x, corner_y), 2]            elif x < corner_x:                return [_distance(0, x, 0, corner_x), 3]            elif y > corner_y:                return [_distance(y, 0, corner_y, 0), 1]            else:                return [0, 2]        # bottom left        elif corner == 2:            if x < corner_x and y < corner_y:                return [_distance(x, y, corner_x, corner_y), 4]            elif x < corner_x:                return [_distance(0, x, 0, corner_x), 3]            elif y < corner_y:                return [_distance(y, 0, corner_y, 0), 5]            else:                 return [0, 4]        # bottom right        elif corner == 3:            if x > corner_x and y < corner_y:                return [_distance(x, y, corner_x, corner_y), 6]            elif x > corner_x:                return [_distance(0, x, 0, corner_x), 7]            elif y < corner_y:                return [_distance(y, 0, corner_y, 0), 5]            else:                 return [0, 6]        else:            print 'Error: corner out of range'    def ignore_points(self, lidars):        """        Deletes unwanted points from Lidar scan        :param lidars: List of lidar objects        """        rectangles = []        for lidar in lidars:            for i in range(len(lidar.x)-1,-1,-1):                ignore = False                # Check search radius                ignore = True if _distance(0, 0, lidar.x[i], lidar.y[i]) > (COLLISION_SEARCH_RADIUS) else ignore                # Check base                ignore = True if _inRect(lidar.x[i], lidar.y[i], [self.x - (self.w/2), self.y - (self.h/2), self.x + (self.w/2), self.y + (self.h/2)]) else ignore                ignore = True if _inRect(lidar.x[i], lidar.y[i], [self.x - (self.w/2) - 20, self.y - (self.h/2) -20, self.x + (self.w/2)+20, self.y + (self.h/2)+20]) else ignore                # Check lidar                ignore = True if _inCirc(lidar.x[i], lidar.y[i], [lidar.x_pos, lidar.y_pos, lidar.collision_radius]) else ignore                # Check other ignorables                # ignore = True if _inRect(lidar.x[i], lidar.y[i], [-350, -250, -260, 140]) else ignore                # ignore = True if _inRect(lidar.x[i], lidar.y[i], [-1000, 0, self.w/2, 1000]) else ignore                # ignore = True if _inRect(lidar.x[i], lidar.y[i], [x, y, dx, dy]) else ignore                # ignore = True if _inRect(lidar.x[i], lidar.y[i], [x, y, dx, dy]) else ignore                # # Check previous points                # x_prev = lidar.x_prev[i]                # y_prev = lidar.y_prev[i]                # th_prev = lidar.th_prev[i]                # r_prev = lidar.r_prev[i]                if ignore:                    del lidar.x[i]                    del lidar.y[i]                    del lidar.r[i]                    del lidar.theta[i]            # # TEMPORARY: TEST POINT            # lidar.x = [-self.h/2]            # lidar.y = [500 + self.w/2]        return lidars    def simulate_movement(self, x, y, th, dt):        """        Changes x, y, and theta using velocities and dt.        By changing the COLLISION_SEARCH_RESOLUTION constant, you can modify how small each increment is in a curve        :return: x, y, th        """        vx = -self.get_vx()        vy = -self.get_vy()        vth = -self.get_vth()        v = _distance(0, 0, vx, vy)        if vth == 0:            dts = [dt]        else:            dts = [0] * COLLISION_SEARCH_RESOLUTION            for i in range(len(dts)):                dts[i] = dt/COLLISION_SEARCH_RESOLUTION        for dt_inc in dts:            r = _distance(self.x, self.y, x, y)            # Change th, x, y according to dt            dth = vth * dt_inc            th += dth            b = _polarc(self.x, self.y, x, y) + dth            x = r * (cos(radians(b)))            y = r * (sin(radians(b)))            # Change x, y according to vx, vy            v = _distance(0, 0, vx, vy)            a = th + _polarc(0, 0, vx, vy)            # a = b + _polarc(0, 0, vx, vy)            x += (dt_inc * v * cos(radians(a)))            y += (dt_inc * v * sin(radians(a)))        return (x, y, th)    def dist_to_collision(self, lidars, point_x, point_y):        """        Returns minimum of distance to base and distance to lidars        :param lidars: Lidar object        :return: (mm) Distance        """        d = [0] * (len(lidars) + 1)        # Check base        hits_base = self.dist_to_base(point_x, point_y)[0] == 0        d[0] = 0 if hits_base else self.dist_to_base(point_x, point_y)[0]        # Check lidars        hits_lidar = [False] * len(lidars)        for j, lidar in enumerate(lidars):            d1 = _distance(lidar.x_pos, lidar.y_pos, point_x, point_y)            hits_lidar[j] = (d1 <= lidar.collision_radius)            d2 = d1 - lidar.collision_radius            d2 = 0 if d2 < 0 else d2            d[j + 1] = 0 if hits_lidar[j] else d2        return min(d)    def time_to_collision(self, lidars):        '''        Returns Time To Collision (TTC) value given points and velocities        :param lidars: Lidar object        :return: TTC        '''        lidars = self.ignore_points(lidars)        t_collision = COLLISION_SEARCH_TIME_BOUNDARY        collision_point = []        # lidars[0].x = [500]        # lidars[0].y = [-250]        for lidar in lidars:            for i in range(len(lidar.x)):                t_max = COLLISION_SEARCH_TIME_BOUNDARY                t = 0                dt = 0                x_original = lidar.x[i]                y_original = lidar.y[i]                x = x_original                y = y_original                th = 0                v = _distance(0, 0, self.get_vx(), self.get_vy())                r = _distance(0, 0, x_original, y_original)                # Continous Collision Detection                d_prev = self.dist_to_collision(lidars, x, y) + 1                while 1:                    shortest_distance = self.dist_to_collision(lidars, x, y)                    if max(abs(self.get_vx()), abs(self.get_vy()), abs(self.get_vth())) == 0: # Base is not moving                        will_collide = False                        break                    elif shortest_distance <= COLLISION_SEARCH_ERROR: # Point is at first collision                        will_collide = True                        break                    elif (shortest_distance >= d_prev and ((th > 90) or th == 0)) or t >= t_collision:                    # elif shortest_distance >= d_prev or t >= t_collision:                        will_collide = False                        break                    dt = shortest_distance / (v + abs(r*sin(radians(-self.get_vth()))))                    d_prev = shortest_distance                    t += dt                    x, y, th = self.simulate_movement(x, y, th, dt)                # Compute return values                if will_collide and t < t_collision:                    collision_point = [x_original, y_original, x, y]                    t_collision = t        return t_collision, collision_point    def get_control_factor(self, time_to_collision, collision_point):        """        Returns control factor for input velocity give TTC calculation and current velocities        :param time_to_collision: TTC value        :param collision_point: list - [x_original, y_original, x_current, y_current]        :return: control factor from 0-1        """        current_time = time.time()        if len(collision_point) is not 0:            r = _distance(*collision_point)            # (s) braking time (max braking time: 1 s, max speed: 1788.16 mm/s)            braking_time = 1.0 * ((_distance(0, 0, self.get_vx(), self.get_vy()) + (r * sin(radians(self.get_vth()))))/1788.16)        else:            braking_time = 0        cf = (time_to_collision - braking_time)/COLLISION_SEARCH_TIME_BOUNDARY        cf = 1 if cf > 1 else cf        cf = 0 if cf < 0 else cf        dcf = cf - self.cf_prev        dt = current_time - self.previous_time        max_increment = dt * CONTROL_FACTOR_INCREMENT        if dcf > 0 and dcf > (max_increment):            cf = self.cf_prev + (max_increment)        elif dcf < 0 and -dcf > (max_increment):            cf = self.cf_prev - (max_increment)        self.previous_time = current_time        self.cf_prev = cf        return cf    # Movement & Sensing    def set_vx(self, vx = 0):        self.vx = vx    def set_vy(self, vy = 0):        self.vy = vy    def set_vth(self, vth = 0):        self.vth = vth    def get_vx(self):        return self.vx    def get_vy(self):        return self.vy    def get_vth(self):        return self.vth    # Plotting    def plot_closest_trajectory(self, t_collision, collision_point, ax1, resolution = 10):        """        Plots trajectory of point found in TTC method        :param t_collision: TTC value        :param collision_point: list - [x_original, y_original, x_current, y_current]        :param ax1: pyplot axis for plotting        :param resolution: number of points to be plotted        """        if len(collision_point) is not 0:            vx = -self.get_vx()            vy = -self.get_vy()            vth = -self.get_vth()            v = _distance(0, 0, vx, vy)            t_max = t_collision            x_sim = collision_point[0]            y_sim = collision_point[1]            r_sim = _distance(self.x, self.y, x_sim, y_sim)            th = 0            graphx = [x_sim]            graphy = [y_sim]            dt = t_max / resolution            for _ in range(resolution):                # Change th, x, resolution according to dt                dth = vth * dt                th += dth                b = _polarc(self.x, self.y, x_sim, y_sim) + dth                x_sim = r_sim * (cos(radians(b)))                y_sim = r_sim * (sin(radians(b)))                # Change vx, vy according to vth                v = _distance(0, 0, vx, vy)                a = th + _polarc(0, 0, vx, vy)                # Change x, y according to vx, vy                x_sim += (dt * v * cos(radians(a)))                y_sim += (dt * v * sin(radians(a)))                r_sim = _distance(self.x, self.y, x_sim, y_sim)                graphx.append(x_sim)                graphy.append(y_sim)            ax1.plot(graphx, graphy, 'r:')            ax1.plot([collision_point[0], collision_point[2]], [collision_point[1], collision_point[3]], 'r.', markersize=10)"""---------------------------------------------------------Lidar Class:   For retrieving, plotting, and modeling data from Lidar---------------------------------------------------------"""class Lidar:    def __init__(self,lidar_num, x_pos, y_pos, theta_offset, is_flipped, collision_radius):        """        Creates a Lidar object on robot base cneter        :param lidar_num: Which Lidar?        :param x_offset: move Lidar in +x direction        :param y_offset: move Lidar in +y direction        :param theta_offset: move Lidar in -theta direction starting @ 0 degrees N        :param is_flipped: Set true if Lidar is upside down        """        self.lidar_num = lidar_num        if self.lidar_num == 1:        # Connect to Lidar (Linux)            context = pyudev.Context()            for device_ in context.list_devices(subsystem='tty'):                # print dict(device_)                device = dict(device_)                vendor_id = str(device.get('ID_VENDOR_ID', 0))                model_id = str(device.get('ID_MODEL_ID', 0))                if vendor_id == '15d1' and model_id == '0000':                    uart_port = device.get('DEVNAME', '')                    print uart_port                    break            # # Connect to Lidar (OS X)            # if lidar_num == 1:            #     uart_port = '/dev/tty.usbmodem1421'            # elif lidar_num == 2:            #     uart_port = '/dev/tty.usbmodem1411'            # Set up Lidar            time.sleep(0.1)            uart_speed = 19200 #115200            laser_serial = serial.Serial(port=uart_port, baudrate=uart_speed, timeout=0.5)            port = serial_port.SerialPort(laser_serial)            # LIDAR_ANG_RES = 0.05 #(degrees) - Angular resolution of Lidar            self.laser = hokuyo.Hokuyo(port)            self.port = uart_port        elif self.lidar_num == 2:            self.laser = HokuyoLX(addr=('192.168.0.10', 10940))        is_connected = True        # Define values        self.theta_offset = theta_offset        self.x_pos = x_pos        self.y_pos = y_pos        self.is_flipped = is_flipped        self.collision_radius = collision_radius        self.scanTime = time.time()        self.x_prev = []        self.y_prev = []        self.theta_prev = []        self.r_prev = []        self.x = []        self.y = []        self.theta = []        self.r = []    def get_data(self):        """        Retrieves raw data from Lidar and transforms to X, Y coordinates        """        # Prepare for data acquisition        self.x_prev = self.x[:]        self.y_prev = self.y[:]        self.theta_prev = self.theta[:]        self.r_prev = self.r[:]        self.dt = time.time() - self.scanTime        self.scanTime = time.time()        # Collect data        # keys -> angles (degrees)        # values -> distances (mm)        print self.lidar_num        if self.lidar_num == 1: # Hokuyo UTM-30LX            self.laser.reset()            self.laser.laser_on()            scan = self.laser.get_single_scan()            keys = scan.keys()            values = scan.values()        elif self.lidar_num == 2:   # Hokuyo UST-10LX            timestamps, scan = self.laser.get_filtered_dist()            scan = scan.tolist()            keys = [0]*len(scan)            values = [0]*len(scan)            for index in range(len(scan)):                keys[index] = degrees(scan[index][0]) # Convert to degrees, 0 @ +x axis                values[index] = scan[index][1]        self.x = [0]*len(keys)        self.y = [0]*len(keys)        self.theta = [0]*len(keys)        self.r = [0]*len(keys)        # Transform data        for point in range(0,len(keys)):            if self.lidar_num == 1:                if not self.is_flipped:                    self.theta[point] = -keys[point] + 90 + self.theta_offset                else:                    self.theta[point] = keys[point] - 90 + self.theta_offset            else:                if  self.is_flipped:                    self.theta[point] = -keys[point]  + self.theta_offset                else:                    self.theta[point] = keys[point]  + self.theta_offset            self.r[point] = values[point]            self.x[point] = values[point]*cos(radians(self.theta[point]))+ self.x_pos            self.y[point] = values[point]*sin(radians(self.theta[point]))+ self.y_pos        # except:        #     print "Lidar communication error"        #     time.sleep(0.2)    def sort_by_distance(self, base):        """        Sorts points into zones by distance to base        RED: extremely close        YELLOW: within a potentially dangerous distance        GREEN: within a safe distance        """        self.green_x = []        self.green_y = []        self.yellow_x = []        self.yellow_y = []        self.red_x = []        self.red_y = []        self.distance = [0]*len(self.r)        # GREEN ZONE:        d > yellow_max        # YELLOW ZONE:      red_max < d <= yellow_max        # RED ZONE:          0 <= d <=  red_max        yellow_max = 300        red_max = 100        for point in range(0, len(self.r)):            dist = base.dist_to_base(self.x[point], self.y[point])[0]            self.distance[point] = dist            if dist > yellow_max:                self.green_x.append(self.x[point])                self.green_y.append(self.y[point])            elif dist > red_max:                self.yellow_x.append(self.x[point])                self.yellow_y.append(self.y[point])            else:                self.red_x.append(self.x[point])                self.red_y.append(self.y[point])'''-----------------------------------------------------------------------Filter Class:    Uses bayesian filtering to classify points as 'tether' or 'obstacle'-----------------------------------------------------------------------'''# Bayes Theorem: P(H|D) = [P(H) * P(D|H)]/P(D)# H = Hypothesis: Point is a tether, point is an obstacle# D = Data: Point distance from tether/obstacleclass Filter:    def __init__(self, base, lidar):        self.base = base        self.lidar = lidar        self.lidar.get_data()        self.tethers = [] # Tether = [x1, y1, x2, y2]        self.tethers.append([base.x-(base.w/2)-5, base.y+180, base.x-(base.w/2)-105, base.y+180]) # Power cable        self.tethers.append([200, -800 , 200, -850]) # Ethernet cable        self.tether_p = [1.0] * len(lidar.x)        self.tether_index = [1.0] * len(lidar.x)        self.obstacle_p = [1.0] * len(lidar.x)        self.tether_p_prev = [1.0] * len(lidar.x)        self.obstacle_p_prev = [1.0] * len(lidar.x)        self.classes = [('obstacle', 0)] * len(lidar.x)        pass    # P(D)_1    def p_tether(self, px, py, tx1, ty1, tx2, ty2):        """        Returns probability that point is a tether point (Tether: any object anchored to robot)        :param tx1, ty1: point 1 of tether segment model        :param tx2, ty2: point 2 of tether segment model        :param px, py: test point        """        d = _distancePointLine(px, py, tx1, ty1, tx2, ty2)        p = min(1, max(0.0,((-1.0/50.0)*abs(float(d))) + 1.0))        return p    # P(D)_2    def p_obstacle(self, px, py, estx, esty):        """        Returns probability that point is an obstacle point        :param estx, esty estimated point location        :param px, py: test point        """        d = _distance(px, py, estx, esty)        # sig = 1        # p = (1 / (sig * sqrt(2 * pi))) * exp(-(d ** 2) / (2 * sig ** 2))        p = min(1, max(0.0,((-1.0/50.0)*abs(float(d))) + 1.0))        # return p        return 0    # P(D|H)    def point_distribution(self, x, y, xestimate, yestimate):        # Tether probability        tetherps = [0] * len(self.tethers)        for i, tether in enumerate(self.tethers):            tetherps[i] = self.p_tether(x, y, tether[0], tether[1], tether[2], tether[3])        tetherp = max(tetherps)        tether_index = tetherps.index(tetherp)        # Obstacle probability        obstaclep = self.p_obstacle(x, y, xestimate, yestimate)        return tetherp, tether_index, obstaclep    # Uses current points to update tether position estimates    def update_models(self):        tetherpoints = [[],[]]        for i in range(len(self.lidar.x)):            if self.classes[i][0] == 'tether':                if self.classes[i][1] == 0:                    # Power cable                    tetherpoints[0].append((self.lidar.x[i],self.lidar.y[i]))                elif self.classes[i][1] == 1:                    # Ethernet cable                    tetherpoints[1].append((self.lidar.x[i],self.lidar.y[i]))        # Power cable        if len(tetherpoints[0]) >= 3:            ysum = 0            for point in tetherpoints[0]:                ysum += point[1]            ymean = ysum/float(len(tetherpoints[0]))            self.tethers[0][1] = ymean            self.tethers[0][3] = ymean    # Bayes Theorem (Main method of this class)    def classify_points(self):        self.tether_p_prev = self.tether_p[:]        self.obstacle_p_prev = self.obstacle_p[:]        for i in range(len(self.lidar.x)):            x = self.lidar.x[i]            y = self.lidar.y[i]            # Get index for closest previous point            closest_index = i            distance = 10000            for j in range(len(self.lidar.x_prev)):                xtest, ytest, _ = self.base.simulate_movement(self.lidar.x_prev[j], self.lidar.y_prev[j], 0, self.base.dt)                if _distance(x, y, xtest, ytest) < distance:                    distance = _distance(x, y, xtest, ytest)                    closest_index = j            # Update instance probabilities            if len(self.lidar.x_prev) >= 1:                tetherp, tether_index, obstaclep = self.point_distribution(self.lidar.x[i], self.lidar.y[i], self.lidar.x_prev[closest_index], self.lidar.y_prev[closest_index])            else:                tetherp, tether_index, obstaclep = self.point_distribution(self.lidar.x[i], self.lidar.y[i], self.lidar.x[i], self.lidar.y[i])            # Update running probabilities            #    P(H|D)      =       P( )            *        P(D|H)            # No division by P(D) because it is constant - does not affect comparison            self.tether_p[i] = float(self.tether_p_prev[closest_index]) * tetherp            self.tether_index[i] = tether_index            self.obstacle_p[i] = float(self.obstacle_p_prev[closest_index]) * obstaclep            # Normalize running probabilities: P(H|D)/P(D)            n = self.tether_p[i] + self.obstacle_p[i]            n = 1 if n == 0 else float(n) # To prevent division by 0 when both probabilities == 0            self.tether_p[i] /= n            self.obstacle_p[i] /= n            # Classify using running probabilities            if self.tether_p[i] > self.obstacle_p[i]:                self.classes[i] = ('tether', self.tether_index[i])            else:                self.classes[i] = ('obstacle', 0)            # # For testing            # px = self.lidar.x[i]            # py = self.lidar.y[i]            # tx1 = self.tethers[0][0]            # ty1 = self.tethers[0][1]            # tx2 = self.tethers[0][2]            # ty2 = self.tethers[0][3]            # if -500 < self.lidar.x[i] < 0 and 0 < self.lidar.y[i] < 500:            #     print self.tether_p[i], self.tether_p_prev[closest_index], tetherp, ':', self.obstacle_p[i], self.obstacle_p_prev[closest_index], obstaclep,'--', _distancePointLine(px, py, tx1, ty1, tx2, ty2), self.lidar.dt        # Update tether models using current classifications        self.update_models()"""------------------------Private module functions------------------------"""def _distance(x1, y1, x2, y2):    '''    Distance formula between 2 points    '''    return sqrt((x1-x2)**2+(y1-y2)**2)def _distancePointLine (px, py, x1, y1, x2, y2):    #http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/source.vba    LineMag = _distance(x1, y1, x2, y2)    if LineMag < 0.00000001:        DistancePointLine = 9999        return DistancePointLine    u1 = (((px - x1) * (x2 - x1)) + ((py - y1) * (y2 - y1)))    u = u1 / (LineMag * LineMag)    if (u < 0.00001) or (u > 1):        #// closest point does not fall within the line segment, take the shorter distance        #// to an endpoint        ix = _distance(px, py, x1, y1)        iy = _distance(px, py, x2, y2)        if ix >= iy:            DistancePointLine = iy        else:            DistancePointLine = ix    else:        # Intersecting point is on the line, use the formula        ix = x1 + u * (x2 - x1)        iy = y1 + u * (y2 - y1)        DistancePointLine = _distance(px, py, ix, iy)    return DistancePointLinedef _angle(x1, y1, x2, y2):    '''    Angle between 2 points (degrees)    '''    return degrees(atan((float(y2) - float(y1))/(float(x2) - float(x1))))def _polarc(x1, y1, x2, y2):    """    Polar coordinate angle between two points, with first point at vertex    """    dx = float(x2) - float(x1)    dy = float(y2) - float(y1)    if dx == 0: return 90 if dy >= 0 else 270    else:        a = degrees(atan(fabs(dy/dx)))        if dx >= 0:            if dy >= 0:                return a            else:                return 360 - a        else:            if dy >= 0:                return 180 - a            else:                return 180 + adef _inRect(point_x, point_y, rectangle):    """    Check if point is in rectangle    rectangle = [corner_x (bottom left), corner_y, oppCorner_x (top right), oppCorner_y]    """    xtest = rectangle[0] <= point_x <= rectangle[2]    ytest = rectangle[1] <= point_y <= rectangle[3]    return xtest and ytestdef _inCirc(point_x, point_y, circle):    """    Check if point is in circle    circle = [center_x, center_y, radius]    """    return _distance(point_x, point_y, circle[0], circle[1]) <= circle[2]